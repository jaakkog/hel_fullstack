{"ast":null,"code":"import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\n\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\nvar emptySchemaConfig = new GraphQLSchema({\n  directives: []\n}).toConfig();\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}","map":{"version":3,"sources":["/Users/jaakkogummerus/Desktop/hel-fullstack/part8/library-frontend/node_modules/graphql/utilities/buildASTSchema.mjs"],"names":["devAssert","Kind","parse","assertValidSDL","GraphQLSchema","GraphQLSkipDirective","GraphQLIncludeDirective","GraphQLDeprecatedDirective","extendSchemaImpl","buildASTSchema","documentAST","options","kind","DOCUMENT","assumeValid","assumeValidSDL","config","emptySchemaConfig","astNode","_i2","_config$types2","types","length","type","name","query","mutation","subscription","directives","some","directive","push","toConfig","buildSchema","source","document","noLocation","allowLegacySDLEmptyFields","allowLegacySDLImplementsInterfaces","experimentalFragmentVariables","commentDescriptions"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,0BAAtB;AACA,SAASC,IAAT,QAAqB,uBAArB;AACA,SAASC,KAAT,QAAsB,wBAAtB;AACA,SAASC,cAAT,QAA+B,4BAA/B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AACA,SAASC,oBAAT,EAA+BC,uBAA/B,EAAwDC,0BAAxD,QAA0F,wBAA1F;AACA,SAASC,gBAAT,QAAiC,oBAAjC;AAEA;;;;;;;;;;;;;;;;;AAgBA,OAAO,SAASC,cAAT,CAAwBC,WAAxB,EAAqCC,OAArC,EAA8C;AACnDD,EAAAA,WAAW,IAAI,IAAf,IAAuBA,WAAW,CAACE,IAAZ,KAAqBX,IAAI,CAACY,QAAjD,IAA6Db,SAAS,CAAC,CAAD,EAAI,kCAAJ,CAAtE;;AAEA,MAAI,CAACW,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACG,WAA3D,MAA4E,IAA5E,IAAoF,CAACH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACI,cAA3D,MAA+E,IAAvK,EAA6K;AAC3KZ,IAAAA,cAAc,CAACO,WAAD,CAAd;AACD;;AAED,MAAIM,MAAM,GAAGR,gBAAgB,CAACS,iBAAD,EAAoBP,WAApB,EAAiCC,OAAjC,CAA7B;;AAEA,MAAIK,MAAM,CAACE,OAAP,IAAkB,IAAtB,EAA4B;AAC1B,SAAK,IAAIC,GAAG,GAAG,CAAV,EAAaC,cAAc,GAAGJ,MAAM,CAACK,KAA1C,EAAiDF,GAAG,GAAGC,cAAc,CAACE,MAAtE,EAA8EH,GAAG,EAAjF,EAAqF;AACnF,UAAII,IAAI,GAAGH,cAAc,CAACD,GAAD,CAAzB;;AAEA,cAAQI,IAAI,CAACC,IAAb;AACE;AACA;AACA;AACA,aAAK,OAAL;AACER,UAAAA,MAAM,CAACS,KAAP,GAAeF,IAAf;AACA;;AAEF,aAAK,UAAL;AACEP,UAAAA,MAAM,CAACU,QAAP,GAAkBH,IAAlB;AACA;;AAEF,aAAK,cAAL;AACEP,UAAAA,MAAM,CAACW,YAAP,GAAsBJ,IAAtB;AACA;AAdJ;AAgBD;AACF;;AAED,MAAIK,UAAU,GAAGZ,MAAM,CAACY,UAAxB,CAhCmD,CAgCf;;AAEpC,MAAI,CAACA,UAAU,CAACC,IAAX,CAAgB,UAAUC,SAAV,EAAqB;AACxC,WAAOA,SAAS,CAACN,IAAV,KAAmB,MAA1B;AACD,GAFI,CAAL,EAEI;AACFI,IAAAA,UAAU,CAACG,IAAX,CAAgB1B,oBAAhB;AACD;;AAED,MAAI,CAACuB,UAAU,CAACC,IAAX,CAAgB,UAAUC,SAAV,EAAqB;AACxC,WAAOA,SAAS,CAACN,IAAV,KAAmB,SAA1B;AACD,GAFI,CAAL,EAEI;AACFI,IAAAA,UAAU,CAACG,IAAX,CAAgBzB,uBAAhB;AACD;;AAED,MAAI,CAACsB,UAAU,CAACC,IAAX,CAAgB,UAAUC,SAAV,EAAqB;AACxC,WAAOA,SAAS,CAACN,IAAV,KAAmB,YAA1B;AACD,GAFI,CAAL,EAEI;AACFI,IAAAA,UAAU,CAACG,IAAX,CAAgBxB,0BAAhB;AACD;;AAED,SAAO,IAAIH,aAAJ,CAAkBY,MAAlB,CAAP;AACD;AACD,IAAIC,iBAAiB,GAAG,IAAIb,aAAJ,CAAkB;AACxCwB,EAAAA,UAAU,EAAE;AAD4B,CAAlB,EAErBI,QAFqB,EAAxB;AAGA;;;;;AAKA,OAAO,SAASC,WAAT,CAAqBC,MAArB,EAA6BvB,OAA7B,EAAsC;AAC3C,MAAIwB,QAAQ,GAAGjC,KAAK,CAACgC,MAAD,EAAS;AAC3BE,IAAAA,UAAU,EAAEzB,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACyB,UAD3C;AAE3BC,IAAAA,yBAAyB,EAAE1B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC0B,yBAF1D;AAG3BC,IAAAA,kCAAkC,EAAE3B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC2B,kCAHnE;AAI3BC,IAAAA,6BAA6B,EAAE5B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC4B;AAJ9D,GAAT,CAApB;AAMA,SAAO9B,cAAc,CAAC0B,QAAD,EAAW;AAC9BK,IAAAA,mBAAmB,EAAE7B,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC6B,mBADjD;AAE9BzB,IAAAA,cAAc,EAAEJ,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACI,cAF5C;AAG9BD,IAAAA,WAAW,EAAEH,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACG;AAHzC,GAAX,CAArB;AAKD","sourcesContent":["import devAssert from \"../jsutils/devAssert.mjs\";\nimport { Kind } from \"../language/kinds.mjs\";\nimport { parse } from \"../language/parser.mjs\";\nimport { assertValidSDL } from \"../validation/validate.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { GraphQLSkipDirective, GraphQLIncludeDirective, GraphQLDeprecatedDirective } from \"../type/directives.mjs\";\nimport { extendSchemaImpl } from \"./extendSchema.mjs\";\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * Accepts options as a second argument:\n *\n *    - commentDescriptions:\n *        Provide true to use preceding comments as the description.\n *\n */\nexport function buildASTSchema(documentAST, options) {\n  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, 'Must provide valid Document AST.');\n\n  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {\n      var type = _config$types2[_i2];\n\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          config.query = type;\n          break;\n\n        case 'Mutation':\n          config.mutation = type;\n          break;\n\n        case 'Subscription':\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  var directives = config.directives; // If specified directives were not explicitly declared, add them.\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'skip';\n  })) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'include';\n  })) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(function (directive) {\n    return directive.name === 'deprecated';\n  })) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema(config);\n}\nvar emptySchemaConfig = new GraphQLSchema({\n  directives: []\n}).toConfig();\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\n\nexport function buildSchema(source, options) {\n  var document = parse(source, {\n    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,\n    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,\n    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,\n    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables\n  });\n  return buildASTSchema(document, {\n    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,\n    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  });\n}\n"]},"metadata":{},"sourceType":"module"}