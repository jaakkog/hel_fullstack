{"ast":null,"code":"import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"sources":["/Users/jaakkogummerus/Desktop/hel-fullstack/part8/library-frontend/node_modules/graphql/utilities/buildClientSchema.mjs"],"names":["objectValues","inspect","devAssert","keyValMap","isObjectLike","parseValue","GraphQLDirective","specifiedScalarTypes","introspectionTypes","TypeKind","GraphQLSchema","isInputType","isOutputType","GraphQLScalarType","GraphQLObjectType","GraphQLInterfaceType","GraphQLUnionType","GraphQLEnumType","GraphQLInputObjectType","GraphQLList","GraphQLNonNull","assertNullableType","assertObjectType","assertInterfaceType","valueFromAST","buildClientSchema","introspection","options","__schema","concat","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","_i2","_ref2","length","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","values","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","_directiveIntrospectionStr","isRepeatable","slice"],"mappings":"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","sourcesContent":["import objectValues from \"../polyfills/objectValues.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport keyValMap from \"../jsutils/keyValMap.mjs\";\nimport isObjectLike from \"../jsutils/isObjectLike.mjs\";\nimport { parseValue } from \"../language/parser.mjs\";\nimport { GraphQLDirective } from \"../type/directives.mjs\";\nimport { specifiedScalarTypes } from \"../type/scalars.mjs\";\nimport { introspectionTypes, TypeKind } from \"../type/introspection.mjs\";\nimport { GraphQLSchema } from \"../type/schema.mjs\";\nimport { isInputType, isOutputType, GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLList, GraphQLNonNull, assertNullableType, assertObjectType, assertInterfaceType } from \"../type/definition.mjs\";\nimport { valueFromAST } from \"./valueFromAST.mjs\";\n\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {\n    var stdType = _ref2[_i2];\n\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: objectValues(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      var nullableType = getType(nullableRef);\n      return GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n\n    var type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n\n  function buildType(type) {\n    if (type != null && type.name != null && type.kind != null) {\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}