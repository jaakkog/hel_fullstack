{"ast":null,"code":"import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\n\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\n\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}","map":{"version":3,"sources":["/Users/jaakkogummerus/Desktop/hel-fullstack/part8/library-frontend/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"],"names":["didYouMean","suggestionList","GraphQLError","isTypeDefinitionNode","isTypeSystemDefinitionNode","isTypeSystemExtensionNode","specifiedScalarTypes","KnownTypeNamesRule","context","schema","getSchema","existingTypesMap","getTypeMap","Object","create","definedTypes","_i2","_context$getDocument$2","getDocument","definitions","length","def","name","value","typeNames","keys","concat","NamedType","node","_1","parent","_2","ancestors","typeName","_ancestors$","definitionNode","isSDL","isSDLNode","isSpecifiedScalarName","suggestedTypes","specifiedScalarsNames","reportError","map","type","indexOf","Array","isArray"],"mappings":"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","sourcesContent":["import didYouMean from \"../../jsutils/didYouMean.mjs\";\nimport suggestionList from \"../../jsutils/suggestionList.mjs\";\nimport { GraphQLError } from \"../../error/GraphQLError.mjs\";\nimport { isTypeDefinitionNode, isTypeSystemDefinitionNode, isTypeSystemExtensionNode } from \"../../language/predicates.mjs\";\nimport { specifiedScalarTypes } from \"../../type/scalars.mjs\";\n\n/**\n * Known type names\n *\n * A GraphQL document is only valid if referenced types (specifically\n * variable definitions and fragment conditions) are defined by the type schema.\n */\nexport function KnownTypeNamesRule(context) {\n  var schema = context.getSchema();\n  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);\n  var definedTypes = Object.create(null);\n\n  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {\n    var def = _context$getDocument$2[_i2];\n\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = true;\n    }\n  }\n\n  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));\n  return {\n    NamedType: function NamedType(node, _1, parent, _2, ancestors) {\n      var typeName = node.name.value;\n\n      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {\n        var _ancestors$;\n\n        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;\n        var isSDL = definitionNode != null && isSDLNode(definitionNode);\n\n        if (isSDL && isSpecifiedScalarName(typeName)) {\n          return;\n        }\n\n        var suggestedTypes = suggestionList(typeName, isSDL ? specifiedScalarsNames.concat(typeNames) : typeNames);\n        context.reportError(new GraphQLError(\"Unknown type \\\"\".concat(typeName, \"\\\".\") + didYouMean(suggestedTypes), node));\n      }\n    }\n  };\n}\nvar specifiedScalarsNames = specifiedScalarTypes.map(function (type) {\n  return type.name;\n});\n\nfunction isSpecifiedScalarName(typeName) {\n  return specifiedScalarsNames.indexOf(typeName) !== -1;\n}\n\nfunction isSDLNode(value) {\n  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));\n}\n"]},"metadata":{},"sourceType":"module"}